--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
										E-Commerce App Deployment
											by
										   KASTRO KIRAN V
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------
Step 1
-----------
Use the same Security Group to all the instances that are going to be launched

1.1. Launch 1 VM (Ubuntu, 24.04, t2.large, 20 GB, Name: Jenkins Server)
Open below ports for the Security Group attached to the above VM
_____________________________________________________________________________________________________________________
Port 			| Protocol 	| Service 				| Purpose
_____________________________________________________________________________________________________________________
22 			| TCP 	| SSH 				| Secure shell access to servers for remote login, command execution 
25 			| TCP 	| SMTP 				| Used for sending email between servers (outbound email)
80 			| TCP 	| HTTP 				| Handles unencrypted web traffic; used for serving websites over the internet.
443 			| TCP 	| HTTPS 				| Secure version of HTTP; encrypts communication between browser and server using TLS/SSL.
465 			| TCP 	| SMTPS 				| Secure SMTP; used for sending emails securely with SSL 
6443 		| TCP 	| Kubernetes API server 	| Used for communication with the Kubernetes control plane (kubectl, kubelets, etc.).
3000–10000 	| TCP 	| Service Ports 			| Used for custom application services (e.g., Node.js apps often use 3000)
30000–32767 	| TCP 	| K8S NodePort Services | Kubernetes allocates this range for exposing services via NodePort (to access a service outside the cluster).


1.2. Launch 2 VMs (Ubuntu, 24.04, t2.medium, 20 GB, One VM Name: Nexus Server, Another VM Name: SonarQube Server)
Attach the same security group which is used for Jenkins Server

=============================
1.3. Creation of EKS Cluster
=============================
1.3.1. Creation of IAM user (To create EKS Cluster, its not recommended to create using Root Account)
IAM ----> Users ----> Create User ----> Name: eks-kastro-user, 'Check' Provide access to console, 'Check' I want to create IAM User, Custom Password ----> Next (dont attach any policies) ----> Next ----> Create user

=============================
1.3.2. Attach policies to the user 
=============================
Open the user created ----> 'Permissions' tab ----> In 'Add permissions' dropdown select 'Add permissions' ----> 'Check' Attach policies directly ----> AmazonEC2FullAccess, AmazonEKS_CNI_Policy, AmazonEKSClusterPolicy, AmazonEKSWorkerNodePolicy, AWSCloudFormationFullAccess, IAMFullAccess ----> Next ----> Add permissions

Attach the below inline policy also for the same user
Open the user created ----> 'Permissions' tab ----> In 'Add permissions' dropdown select 'Create Inline Policy' ----> Json ----> Remove any existing policy. Paste the below policy
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": "eks:*",
            "Resource": "*"
        }
    ]
}
 ----> Next ----> Policy Name: eks-inline-policy ----> Create Policy
A total of 7 policies we have attached to the IAM User created in 1.3.1.

=============================
1.3.3. Create Access Keys
=============================
Open the user created ----> Security Credentials tab ----> Create access key ----> Use case: CLI ----> Next ----> Create Keys ----> Download the csv file

Now we have created the IAM User with appropriate permissions to create the EKS Cluster
AKIA6G75DMYKLKKW364G
YNvoMvkeA7uIiNmuw6C5YyLREpi2b1DlAozQWYU3
=============================
1.4. Creation of EKS Cluster 
=============================
Connect to the 'Jenkins Server' VM
sudo apt update

==========================================
1.4.1. Install AWS CLI (to interact with AWS Account)
==========================================
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
sudo apt install unzip
unzip awscliv2.zip
sudo ./aws/install
aws configure

Configure aws
aws configure ----> Paste the Access Key ----> Paste the Secret Access Key ----> Region: ap-south-1 ----> Output: click enter (no need to give anything)

===================================
1.4.2. Install KubeCTL (to interact with K8S)
===================================
curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.19.6/2021-01-05/bin/linux/amd64/kubectl
chmod +x ./kubectl
sudo mv ./kubectl /usr/local/bin
kubectl version --short --client

==========================================
1.4.3. Install EKS CTL (used to create EKS Cluster) 
==========================================
curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
sudo mv /tmp/eksctl /usr/local/bin
eksctl version

=============================
1.4.4. Create EKS Cluster
=============================
Execute the below commands as separate set
(a)
eksctl create cluster --name=kastro-eks \
                      --region=us-east-1 \
                      --zones=us-east-1a,us-east-1b \
                      --version=1.30 \
                      --without-nodegroup

It will take 5-10 minutes to create the cluster
Goto EKS Console and verify the cluster.

(b)
eksctl utils associate-iam-oidc-provider \
    --region us-east-1 \
    --cluster kastro-eks \
    --approve

The above command is crucial when setting up an EKS cluster because it enables IAM roles for service accounts (IRSA)
Amazon EKS uses OpenID Connect (OIDC) to authenticate Kubernetes service accounts with IAM roles.
Associating the IAM OIDC provider allows Kubernetes workloads (Pods) running in the cluster to assume IAM roles securely.
Without this, Pods in EKS clusters would require node-level IAM roles, which grant permissions to all Pods on a node.
Without it, these services will not be able to access AWS resources securely.

(c)
Before executing the below command, in the 'ssh-public-key' keep the  '<PEM FILE NAME>' (dont give .pem. Just give the pem file name) which was used to create Jenkins Server

eksctl create nodegroup --cluster=kastro-eks \
                       --region=us-east-1 \
                       --name=node2 \
                       --node-type=t3.medium \
                       --nodes=3 \
                       --nodes-min=2 \
                       --nodes-max=4 \
                       --node-volume-size=20 \
                       --ssh-access \
                       --ssh-public-key=ecommerce \
                       --managed \
                       --asg-access \
                       --external-dns-access \
                       --full-ecr-access \
                       --appmesh-access \
                       --alb-ingress-access

It will take 5-10 minutes 

(d) For internal communication b/w control plane and worker nodes, we need to open one traffic in the security group of EKS Cluster
Open the cluster created ----> 'Networking' tab ----> Under 'Additional Security Groups' you will see a link, click on that link ----> 'Inbound rules' tab ----> Edit inbound rules ----> Add rule ----> All traffic, Anywhere IPv4 ----> Save rules

-----------
Step 2
-----------
Lets setup Jenkins, Nexus, SonarQube in the respective servers

=============================
2.1.1 Connect to the Jenkins Server
=============================
vi Jenkins.sh ----> Paste the below content ---->
#!/bin/bash

# Install OpenJDK 17 JRE Headless
sudo apt install openjdk-17-jre-headless -y

# Download Jenkins GPG key
sudo wget -O /usr/share/keyrings/jenkins-keyring.asc \
  https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key

# Add Jenkins repository to package manager sources
echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
  https://pkg.jenkins.io/debian-stable binary/ | sudo tee \
  /etc/apt/sources.list.d/jenkins.list > /dev/null

# Update package manager repositories
sudo apt-get update

# Install Jenkins
sudo apt-get install jenkins -y

----> esc ----> :wq ----> sudo chmod +x Jenkins.sh ----> ./Jenkins.sh

Open Port 8080 in Jenkins server
Access Jenkins and setup Jenkins


=============================
2.1.2 Install Docker
=============================
vi docker.sh ----> Paste the below content ---->

#!/bin/bash

# Update package manager repositories
sudo apt-get update

# Install necessary dependencies
sudo apt-get install -y ca-certificates curl

# Create directory for Docker GPG key
sudo install -m 0755 -d /etc/apt/keyrings

# Download Docker's GPG key
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc

# Ensure proper permissions for the key
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add Docker repository to Apt sources
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
$(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Update package manager repositories
sudo apt-get update

sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 

 ----> esc ----> :wq ----> sudo chmod +x docker.sh ----> ./docker.sh

docker --version
Try to pull some default image ----> docker pull hello-world ----> You will be able to pull the image. If you are unable to pull the image. Execute the below command to provide necessary permissions ----> sudo chmod 666 /var/run/docker.sock ----> docker pull hello-world ----> You will be able to pull the image

=============================
2.1.3. Install Trivy on Jenkins Server
=============================
vi trivy.sh ----> Paste the below commands ---->
#!/bin/bash
sudo apt-get install wget apt-transport-https gnupg
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | gpg --dearmor | sudo tee /usr/share/keyrings/trivy.gpg > /dev/null
echo "deb [signed-by=/usr/share/keyrings/trivy.gpg] https://aquasecurity.github.io/trivy-repo/deb generic main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
sudo apt-get update
sudo apt-get install trivy

----> esc ----> :wq ----> sudo chmod +x trivy.sh ----> ./trivy.sh ----> trivy --version

=============================
2.2. SonarQube Setup
=============================
Connect to the SonarQube Server
sudo apt update

Lets setup SonarQube using docker container
vi docker.sh ----> Paste the below content ---->

#!/bin/bash

# Update package manager repositories
sudo apt-get update

# Install necessary dependencies
sudo apt-get install -y ca-certificates curl

# Create directory for Docker GPG key
sudo install -m 0755 -d /etc/apt/keyrings

# Download Docker's GPG key
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc

# Ensure proper permissions for the key
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add Docker repository to Apt sources
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
$(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Update package manager repositories
sudo apt-get update

sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 

 ----> esc ----> :wq ----> sudo chmod +x docker.sh ----> ./docker.sh

docker --version
sudo chmod 666 /var/run/docker.sock

Lets install SonarQube ----> docker run -d --name sonar -p 9000:9000 sonarqube:lts-community
docker images
docker ps

Access SonarQube, after opening port 9000 for SonarQube server
Default username and Password: admin
Set new password
=============================
2.3 Nexus Setup
=============================
Connect to the Nexus Server
sudo apt update

Lets setup Nexus using docker container
vi docker.sh ----> Paste the below content ---->

#!/bin/bash

# Update package manager repositories
sudo apt-get update

# Install necessary dependencies
sudo apt-get install -y ca-certificates curl

# Create directory for Docker GPG key
sudo install -m 0755 -d /etc/apt/keyrings

# Download Docker's GPG key
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc

# Ensure proper permissions for the key
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add Docker repository to Apt sources
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
$(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Update package manager repositories
sudo apt-get update

sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 

 ----> esc ----> :wq ----> sudo chmod +x docker.sh ----> ./docker.sh

docker --version
sudo chmod 666 /var/run/docker.sock

Lets install Nexus ----> docker run -d --name nexus3 -p 8081:8081 sonatype/nexus3
docker images
docker ps

Access Nexus, after opening port 8081 for Nexus server. 
Remember, Nexus wont come immediately in the browser. Wait for sometime and refresh the browser.
Click on Signin ----> Username: admin, To get the password follow as below ----> docker ps ----> Copy the Nexus container ID ----> Lets go inside the container to get the password ----> docker exec -it <ContainerID> /bin/bash ----> ls ----> cd sonatype-work ----> ls ----> cd nexus3 ----> ls ----> cat admin.password ----> Copy the password (dont copy 'bash') ----> Paste in the nexus browser and click on Signin ----> Setup new password ----> Next ----> 'Check' Enable Anonymous Access ----> Next ----> Finish

With this we have setup Jenkins, SonarQube, Nexus and EKS Cluster

-----------
Step 3
-----------
=============================
3.1. Jenkins Plugin Installation
=============================
Install below plugins;
Eclipse Temurin Installer, SonarQube scanner, Docker, Docker Commons, Docker Pipeline, Docker API, docker-build-step, Pipeline stage view, Email Extension Template, Kubernetes, Kubernetes CLI, Kubernetes Client API, Kubernetes Credentials, Config File Provider, Maven Integration, Pipeline Maven Integration, Prometheus metrics ---> install ---> You will see error while installing Prometheus plugin. Read the error message. Here we need to restart the Jenkins ---> 'Check' the box below 'Go back to the top of page' to restart the Jenkins

=============================
3.2. Tool Configuration
=============================
Goto the Jenkins console (since we restarted, login again to Jenkins) ---> Manage Jenkins ---> System Configuration ---> Tools ---> JDK Installation ---> Add JDK ---> Name: jdk17, 'Check' Install automatically, Click on 'Add Installer', Select 'Install from Adoptium.net', Version: jdk-17.0.11+9 ---> SonarQube Scanner Installations ---> Add 'SonarQube Scanner' ---> Name: sonar-scanner, 'Check' Install automatically, Version: Select the latest version 7.0.0.4796 ---> Maven Installations ---> Add Maven ---> Name: maven, Version: 3.9.9 ---> Docker Installations ---> Add Docker---> Name: docker, 'Check' Install automatically,  Click on 'Add Installer', Select 'Download from docker.com', Version: latest ---> Apply ---> Save

==========================================
3.3. System Configuration in Jenkins for SonarQube
==========================================
Lets configure the SonarQube server;
Goto SonarQube console --- Click on 'Administration' --- Click on 'Security' --- Select 'Users' --- You can see 'Tokens' --- Click on 3 dashes icon --- A New dialogue --- Name: token, Expires in: 90days --- Generate --- You can see token in green colour. Copy it. 
Token: squ_dcc638876ea585af501be08adbb861667932da03

Manage Jenkins --- Security --- Credentials --- Click on 'global' --- Click on 'Add Credentials' --- Kind: Secret text, Scope: Global, Secret: <Paste the token copied from SonarQube console>, ID: sonar-token, Description: sonar-token --- Create

Creation of SonarQube webhooks ----> Administration ----> 'Configuration' dropdown ----> Webhooks ----> Click on 'Create' ----> Name: jenkins, URL: <JenkinsURL>:8080/sonarqube-webhook/ ---> Create

Manage Jenkins ---> System ---> Scroll down to 'SonarQube servers' ---> Click on 'Add SonarQube'  ---> Name: sonar, Server URL: paste the SonarQube url. Paste only upto 9000. Dont keep / at the end, Server Authentication Token: Select the 'sonar-token' from drop down ---> Apply ---> Save

===================================================
3.4. Nexus Configuration (to publish the artifacts to the Nexus Repo)
===================================================
Nexus Browser ----> Browse (left pane) ----> You can see 'maven-releases' and 'maven-snapshots'. 'maven-releases' contains the artifacts that need to be deployed to Production Server and 'maven-snapshots' contains the artifacts that need to be deployed to Lower Servers i.e Dev Envi, Test Envi.

Before doing the configuration of nexus, we need to edit the pom.xml file in the GitHub repo. 
Open pom.xml ----> At the bottom, after 'dependencies' tag paste the below content, exactly in the line of 'dependencies' tag.

<distributionManagement>
  <repository>
    <id>maven-releases</id>
    <url>http://54.153.23.195:8081/repository/maven-releases/</url>
  </repository>
  <snapshotRepository>
    <id>maven-snapshots</id>
    <url>http://54.153.23.195:8081/repository/maven-snapshots/</url>
  </snapshotRepository>
</distributionManagement>


From the Nexus browser, copy the 'maven-releases' link and paste in the above content.
From the Nexus browser, copy the 'maven-snapshots' link and paste in the above content.
Save the pom.xml file in the GitHub repo.

Lets configure Nexus in the Jenkins;
Manage Jenkins --- System Configuration --- Managed Files --- Add a new config  --- Type: Global Maven Settings.xml, Scroll down to ID: maven-setting --- Next --- Scroll down to 'server' tag --- Just above 'another sample' you will see -->, remove that and paste it above the 'server' tag. You can see everything changed to green --- Under 'server' tag, you will see 'deployment repo', remove this and type 'maven-releases' (dont keep single quotes), change the username as 'admin', change the password as 'kastro'.
Copy the entire edited content and paste below it. Now lets do the same for maven-snapshots;
in the place of 'maven-releases' provide 'maven-snapshots'. No need to change the username and password --- Submit

======================================
3.4.1. Nexus configuration for Jenkins Pipeline
======================================
In the Nexus stage of pipeline, to generate the pipeline syntax, follow as below;
Open Jenkins Job --- Pipeline Syntax --- Sample step: withMaven: provide Maven environment, Maven: maven, JDK: jdk17, Maven Settings Config: use system default settings or file path, Global maven settings config: MyGlobalSettings --- Generate pipeline syntax --- Copy the syntax and paste in the pipeline script 

======================================
3.5. Docker configuration for Jenkins Pipeline
======================================
In the Docker Build & Tag Docker Image stage of pipeline, to generate the pipeline syntax, follow as below;
Open Jenkins Job --- Pipeline Syntax --- Sample step: withDockerRegistry: Sets up Docker Registry Endpoint, Docker registry URL: (since its a public docker registry, we dont have provide the docker hub URL) --- Registry credentials: Add: Jenkins: Domain: Global Credentials, Kind: Username with password, Scope: Global, Username: <DockerHubUserName>, Password: <DockerHubPassword>, ID: docker-cred, Description: docker-cred --- Add --- Registry credentials: Select 'docker-cred' from dropdown, Docker installation: docker --- Generate pipeline syntax --- Copy the syntax and paste in the pipeline script.

==============================
Lets create a mail notification;
==============================
Goto Gmail ---> Click on Icon on top right ---> Click on 'Your google account' ---> 'Security' (left pane) --->Make sure 2 step verification is on.

Goto Gmail ---> Click on Icon on top right ---> Click on 'Your google account' ---> in search box at top, search for 'App  Passwords' and click on it, Enter password of gmail ---> Next ---> App name: jenkins ---> Create ---> You can see the password (ex: sbksmfpgvycqibug) ---> Copy it ---> Make sure to remove the spaces in the password. Lets configure this password in Jenkins.

Manage Jenkins ---> System ---> Scroll down to 'Email Notification' ---> SMTP Server: smtp.gmail.com ---> Click on 'Advanced'  ---> 'Check' Use SMTP Authentication, Username: <ProvideEmailID>, Password: <PasteThePasswordToken>, 'Check' Use SSL, SMTP Port: 465, Reply-to-email: <ProvideEmail>, Charset: UTF-8,, Check 'Test configuration by sending test e-mail', Test Email Recepient: <provide-email-id>, Click on 'Test Configuration' ---> You can see 'email sent' ---> Goto email and check for test email

Manage Jenkins* ---> System ---> Scroll up to 'Extended Email Notification' ---> SMTP Server: smtp.gmail.com ---> SMTP Port: 465, Click on 'Advanced'  ---> Credentials: Select 'email creds' from drop down, 'Check' Use SSL and Use OAuth 2.0, Default content type: HTML

Goto the Jenkins console ---> Manage Jenkins ---> Security ---> Credentials ---> Under 'Stores scoped to Jenkins', Click on 'Global' under 'Domains' ---> Add credentials ---> A dia ---> Kind: Username with Password, Scope: Global, Username: <ProvideEmail ID>, Password: <PasteTheToken>, ID: mail-cred, Description: mail-cred, 'Check' Use SSL ---> Create ---> You can see the email credentials got created.

Manage Jenkins* ---> System ---> Scroll down to 'Extended Email Notification' ---> SMTP Server: smtp.gmail.com ---> SMTP Port: 465, Click on 'Advanced'  ---> Credentials: Select 'mail-cred' from drop down, 'Check' Use SSL and Use OAuth 2.0, Default content type: HTML

Lets* make another configuration to get an email when build fails/success ---> Goto 'Default Triggers' drop down (If you cannot find this, try searching using control+f ---> 'Check' Always, Failure-Any, Success ---> Apply ---> Save 

=============================
3.6. Job Creation
=============================
Goto MobaXTerm Terminal ---> Login to DockerHub ---> docker login -u <DockerHubUserName> ---> Click Enter ---> Enter the password of DockerHub

Create a pipeline job
______________________________
Pipeline Script (without K8S Stage)
_____________________________
pipeline {
    agent any

    tools {
        jdk 'jdk17'
        maven 'maven'
    }

    environment {
        SCANNER_HOME = tool 'sonar-scanner'
        DOCKER_IMAGE = "kastrov/ecommerce:latest"
    }

    stages {
        stage('Git Checkout') {
            steps {
                git 'https://github.com/KastroVKiran/Ecommerce-App-Kastro.git'
            }
        }

        stage('Maven Compile') {
            steps {
                sh "mvn compile"
            }
        }

        stage('Maven Test') {
            steps {
                sh "mvn test -DskipTests=true"
            }
        }

        stage('File System Scan') {
            steps {
                sh "trivy fs --format table -o trivy-fs-report.html ."
            }
        }

        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('sonar') {
                    sh '''
                    $SCANNER_HOME/bin/sonar-scanner \
                    -Dsonar.projectName=ECommerce \
                    -Dsonar.projectKey=ECommerce \
                    -Dsonar.java.binaries=target/classes
                    '''
                }
            }
        }

        stage('Maven Build') {
            steps {
                sh "mvn package -DskipTests=true"
            }
        }

        stage('Publish to Nexus') {
            steps {
                withMaven(globalMavenSettingsConfig: 'maven-setting', jdk: 'jdk17', maven: 'maven') {
                    sh "mvn deploy -DskipTests=true"
                }
            }
        }

        stage('Docker Build & Tag') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'docker-cred') {
                        sh "docker build -t ${DOCKER_IMAGE} ."
                    }
                }
            }
        }

        stage('Docker Image Scan') {
            steps {
                sh "trivy image --format table -o trivy-image-report.html ${DOCKER_IMAGE}"
                archiveArtifacts artifacts: 'trivy-image-report.html', fingerprint: true
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'docker-cred') {
                        sh "docker push ${DOCKER_IMAGE}"
                    }
                }
            }
        }

        stage('Deploy to Container') {
            steps {
                script {
                    sh "docker stop ecommerce-container || true && docker rm ecommerce-container || true"
                    sh "docker run -d --name ecommerce-container -p 8083:8080 ${DOCKER_IMAGE}"
                }
            }
        }
    }

    post {
        always {
            script {
                def jobName = env.JOB_NAME
                def buildNumber = env.BUILD_NUMBER
                def pipelineStatus = currentBuild.result ?: 'SUCCESS'
                def bannerColor = pipelineStatus.toUpperCase() == 'SUCCESS' ? 'green' : 'red'

                def body = """
                <html>
                <body>
                <div style="border: 4px solid ${bannerColor}; padding: 10px;">
                <h2>${jobName} - Build ${buildNumber}</h2>
                <div style="background-color: ${bannerColor}; padding: 10px;">
                <h3 style="color: white;">Pipeline Status: ${pipelineStatus.toUpperCase()}</h3>
                </div>
                <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                </div>
                </body>
                </html>
                """

                emailext (
                    subject: "${jobName} - Build ${buildNumber} - ${pipelineStatus.toUpperCase()}",
                    body: body,
                    to: 'kastrokiran@gmail.com',
                    from: 'jenkins@example.com',
                    replyTo: 'jenkins@example.com',
                    mimeType: 'text/html',
                    attachmentsPattern: 'trivy-image-report.html'
                )
            }
        }
    }
}

---------------------------------------
Deploying to EKS Cluster
---------------------------------------

=============================
5 Create Service Account, Role & Assign that role, And create a secret for Service Account and generate a Token
=============================
Here we will create all the resources inside a namespace called 'webapps' which is a recommended approach in the realtime scenario
(a) Creating Service Account 
vi svc.yml ---->
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: webapps

Lets create a namespace ---> kubectl create namespace webapps ---> kubectl apply -f svc.yml

(b) Create Role
vi role.yml ---->
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: app-role
  namespace: webapps
rules:
  - apiGroups:
        - ""
        - apps
        - autoscaling
        - batch
        - extensions
        - policy
        - rbac.authorization.k8s.io
    resources:
      - pods
      - componentstatuses
      - configmaps
      - daemonsets
      - deployments
      - events
      - endpoints
      - horizontalpodautoscalers
      - ingress
      - jobs
      - limitranges
      - namespaces
      - nodes
      - pods
      - persistentvolumes
      - persistentvolumeclaims
      - resourcequotas
      - replicasets
      - replicationcontrollers
      - serviceaccounts
      - services
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

 ---> kubectl apply -f role.yml

(c) Bind the role to service account
vi bind.yml ---->
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-rolebinding
  namespace: webapps 
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: app-role 
subjects:
- namespace: webapps 
  kind: ServiceAccount
  name: jenkins 

 ---> kubectl apply -f bind.yml

(d) In order to use the service account for deployment, we need to create token for the service account which will be used as authentication
vi secret.yml --- Paste the below content; (reference URL for secret: https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#:~:text=To%20create%20a%20non%2Dexpiring,with%20that%20generated%20token%20data.)

apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
  name: mysecretname
  annotations:
    kubernetes.io/service-account.name: jenkins #Here my service account name is 'jenkins' based on the above created yml files

--- esc --- :wq --- kubectl create apply -f secret.yml -n <NameSpaceName i.e webapps> (MODIFIED COMMAND FOR DEVOPS EXAM APP: kubectl apply -f secret.yml -n webapps) --- Now the secret will get created inside the namespace --- To get the token --- kubectl describe secret <SecretName i.e mysecretname> -n <NameSpaceName i.e webapps> (MODIFIED COMMAND FOR DEVOPS EXAM APP: kubectl describe secret mysecretname -n webapps) --- You can see the token. Copy and paste in notepad
We will configure this in Jenkins in sometime

eyJhbGciOiJSUzI1NiIsImtpZCI6IkNxMkxsR3VNTVlsSGhNRHd2T1F1X1N1eUxOVnJfODdmZHVHZ0E2WHRmdjAifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJ3ZWJhcHBzIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6Im15c2VjcmV0bmFtZSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJqZW5raW5zIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiYjAxNmFmZjctOGE1OC00ZDEyLTlhYjEtY2EwYjcxMzQzYzc1Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OndlYmFwcHM6amVua2lucyJ9.worPaZdFJfeswDgIghIngEjeiZ2x2V9yFQc9qLG3yyJRh5ZOnt3WiHeQkP_wfbLd5vt5r-WIsEA3BjFDI8KMaxgOa9lmrGa9jYQjaEyCw-oErDUz1Xh87Iby_OG1bkmij-sTU4GKXLyoavw5dEr5FLY0iAv2aoAzaUchb-MVoTmxWrTQa3RcVGeraOWIWkv-jP1bq-4eFGAeBm_1HG5KakWJ5Y7gnpNGn6RWAowh_9p0R-VMsirmSmeZ19_-FAdBg0zgjaHtcm317P5wUVMNNT3zxoWL9NN7_VAPFAIgW2SLKID45ww6bfEWiaFNaZETizKfZjhRW5rhS8sIevJe9g

Lets create CD pipeline
Dashboard --- Manage Jenkins --- Security --- Credentials --- Global credentials (unrestricted) --- Kind: secret text --- Scope: global --- Secret: Paste the token generated above --- ID: k8-token, Decription: k8-token --- Create

Pipeline syntax --- Sample step: withKubeCredentials: Configure Kubernetes CLI (kubectl) --- Credentials: k8-token --- Kubernetes Server Endpoint: To get this endpoint, go to EKS Cluster --- Overview tab --- Details --- Copy the API server endpoint and paste it --- Cluster name: <GiveTheNameAsInEKSConsole>, Context name: <leaveBlank>, Namespace: <NameSpaceName i.e webapps>, --- Generate pipeline script --- Copy and paste in the 'Deploy To Kubernetes' and 'verify Deployment' stages in the below pipeline script

___________________________________________________
Ecommerce App - Successful (with K8S Stage)
___________________________________________________
pipeline {
    agent any

    tools {
        jdk 'jdk17'
        maven 'maven'
    }

    environment {
        SCANNER_HOME = tool 'sonar-scanner'
        DOCKER_IMAGE = "kastrov/ecommerce:latest"
    }

    stages {
        stage('Git Checkout') {
            steps {
                git 'https://github.com/KastroVKiran/Ecommerce-App-Kastro.git'
            }
        }

        stage('Maven Compile') {
            steps {
                sh "mvn compile"
            }
        }

        stage('Maven Test') {
            steps {
                sh "mvn test -DskipTests=true"
            }
        }

        stage('File System Scan') {
            steps {
                sh "trivy fs --format table -o trivy-fs-report.html ."
            }
        }

        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('sonar') {
                    sh '''
                    $SCANNER_HOME/bin/sonar-scanner \
                    -Dsonar.projectName=ECommerce \
                    -Dsonar.projectKey=ECommerce \
                    -Dsonar.java.binaries=target/classes
                    '''
                }
            }
        }

        stage('Maven Build') {
            steps {
                sh "mvn package -DskipTests=true"
            }
        }

        stage('Publish to Nexus') {
            steps {
                withMaven(globalMavenSettingsConfig: 'maven-setting', jdk: 'jdk17', maven: 'maven') {
                    sh "mvn deploy -DskipTests=true"
                }
            }
        }

        stage('Docker Build & Tag') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'docker-cred') {
                        sh "docker build -t ${DOCKER_IMAGE} ."
                    }
                }
            }
        }

        stage('Docker Image Scan') {
            steps {
                sh "trivy image --format table -o trivy-image-report.html ${DOCKER_IMAGE}"
                archiveArtifacts artifacts: 'trivy-image-report.html', fingerprint: true
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'docker-cred') {
                        sh "docker push ${DOCKER_IMAGE}"
                    }
                }
            }
        }

        stage('Deploy to Container') {
            steps {
                script {
                    sh "docker stop ecommerce-container || true && docker rm ecommerce-container || true"
                    sh "docker run -d --name ecommerce-container -p 8083:8080 ${DOCKER_IMAGE}"
                }
            }
        }

        // ✅ These two stages were outside of "stages" block before. Moved inside.
        stage('Deploy To Kubernetes') {
            steps {
                withKubeConfig(caCertificate: '', clusterName: 'kastro-eks', contextName: '', credentialsId: 'k8-token', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://A3A38B4561B8159534054B870C447E05.yl4.us-east-1.eks.amazonaws.com') {
                    sh "kubectl apply -f deployment-service.yaml -n webapps"
                }
            }
        }

        stage('Verify the Deployment') {
            steps {
                withKubeConfig(caCertificate: '', clusterName: 'kastro-eks', contextName: '', credentialsId: 'k8-token', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://A3A38B4561B8159534054B870C447E05.yl4.us-east-1.eks.amazonaws.com') {
                    sh "kubectl get pods -n webapps"
                    sh "kubectl get svc -n webapps"
                }
            }
        }
    } // ✅ Correct closing of "stages" block

    post {
        always {
            script {
                def jobName = env.JOB_NAME
                def buildNumber = env.BUILD_NUMBER
                def pipelineStatus = currentBuild.result ?: 'SUCCESS'
                def bannerColor = pipelineStatus.toUpperCase() == 'SUCCESS' ? 'green' : 'red'

                def body = """
                <html>
                <body>
                <div style="border: 4px solid ${bannerColor}; padding: 10px;">
                <h2>${jobName} - Build ${buildNumber}</h2>
                <div style="background-color: ${bannerColor}; padding: 10px;">
                <h3 style="color: white;">Pipeline Status: ${pipelineStatus.toUpperCase()}</h3>
                </div>
                <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                </div>
                </body>
                </html>
                """

                emailext (
                    subject: "${jobName} - Build ${buildNumber} - ${pipelineStatus.toUpperCase()}",
                    body: body,
                    to: 'kastrokiran@gmail.com',
                    from: 'jenkins@example.com',
                    replyTo: 'jenkins@example.com',
                    mimeType: 'text/html',
                    attachmentsPattern: 'trivy-image-report.html'
                )
            }
        }
    }
}


To access the App, we need to get the Load Balancer URL
kuetl get all -n webapps


Step 4: Monitoring
=========================
Launch Ubuntu VM, 22.04, t2.medium,
Name the VM as Monitoring Server

4.1. Connect to the Monitoring Server VM (Execute in Monitoring Server VM)
Create a dedicated Linux user sometimes called a 'system' account for Prometheus
sudo apt update

sudo useradd \
    --system \
    --no-create-home \
    --shell /bin/false prometheus

With the above command, we have created a 'Prometheus' user

Explanation of above command
–system – Will create a system account.
–no-create-home – We don’t need a home directory for Prometheus or any other system accounts in our case.
–shell /bin/false – It prevents logging in as a Prometheus user.
Prometheus – Will create a Prometheus user and a group with the same name.

4.2. Download the Prometheus
sudo wget https://github.com/prometheus/prometheus/releases/download/v2.47.1/prometheus-2.47.1.linux-amd64.tar.gz
tar -xvf prometheus-2.47.1.linux-amd64.tar.gz
sudo mkdir -p /data /etc/prometheus
cd prometheus-2.47.1.linux-amd64/

Move the Prometheus binary and a promtool to the /usr/local/bin/. promtool is used to check configuration files and Prometheus rules.
sudo mv prometheus promtool /usr/local/bin/

Move console libraries to the Prometheus configuration directory
sudo mv consoles/ console_libraries/ /etc/prometheus/

Move the example of the main Prometheus configuration file
sudo mv prometheus.yml /etc/prometheus/prometheus.yml

Set the correct ownership for the /etc/prometheus/ and data directory
sudo chown -R prometheus:prometheus /etc/prometheus/ /data/

Delete the archive and a Prometheus tar.gz file 
cd
You are in ~ path
rm -rf prometheus-2.47.1.linux-amd64.tar.gz

prometheus --version
You will see as "version 2.47.1"

prometheus --help

We’re going to use Systemd, which is a system and service manager for Linux operating systems. For that, we need to create a Systemd unit configuration file.
sudo vi /etc/systemd/system/prometheus.service ---> Paste the below content ---->

[Unit]
Description=Prometheus
Wants=network-online.target
After=network-online.target
StartLimitIntervalSec=500
StartLimitBurst=5
[Service]
User=prometheus
Group=prometheus
Type=simple
Restart=on-failure
RestartSec=5s
ExecStart=/usr/local/bin/prometheus \
  --config.file=/etc/prometheus/prometheus.yml \
  --storage.tsdb.path=/data \
  --web.console.templates=/etc/prometheus/consoles \
  --web.console.libraries=/etc/prometheus/console_libraries \
  --web.listen-address=0.0.0.0:9090 \
  --web.enable-lifecycle
[Install]
WantedBy=multi-user.target

 ----> esc ----> :wq ----> 

To automatically start the Prometheus after reboot run the below command
sudo systemctl enable prometheus

Start the Prometheus
sudo systemctl start prometheus

Check the status of Prometheus
sudo systemctl status prometheus

Open Port No. 9090 for Monitoring Server VM and Access Prometheus
<public-ip:9090>

If it doesn't work, in the web link of browser, remove 's' in 'https'. Keep only 'http' and now you will be able to see.
You can see the Prometheus console.
Click on 'Status' dropdown ---> Click on 'Targets' ---> You can see 'Prometheus (1/1 up)' ----> It scrapes itself every 15 seconds by default.

10. Install Node Exporter (Execute in Monitoring Server VM)
You are in ~ path now

Create a system user for Node Exporter and download Node Exporter:
sudo useradd --system --no-create-home --shell /bin/false node_exporter
wget https://github.com/prometheus/node_exporter/releases/download/v1.6.1/node_exporter-1.6.1.linux-amd64.tar.gz

Extract Node Exporter files, move the binary, and clean up:
tar -xvf node_exporter-1.6.1.linux-amd64.tar.gz
sudo mv node_exporter-1.6.1.linux-amd64/node_exporter /usr/local/bin/
rm -rf node_exporter*

node_exporter --version

Create a systemd unit configuration file for Node Exporter:
sudo vi /etc/systemd/system/node_exporter.service

Add the following content to the node_exporter.service file:
[Unit]
Description=Node Exporter
Wants=network-online.target
After=network-online.target

StartLimitIntervalSec=500
StartLimitBurst=5

[Service]
User=node_exporter
Group=node_exporter
Type=simple
Restart=on-failure
RestartSec=5s
ExecStart=/usr/local/bin/node_exporter --collector.logind

[Install]
WantedBy=multi-user.target

Note: Replace --collector.logind with any additional flags as needed.

Enable and start Node Exporter:
sudo systemctl enable node_exporter
sudo systemctl start node_exporter

Verify the Node Exporter's status:
sudo systemctl status node_exporter
You can see "active (running)" in green colour
Press control+c to come out of the file

4.3. Configure Prometheus Plugin Integration

As of now we created Prometheus service, but we need to add a job in order to fetch the details by node exporter. So for that we need to create 2 jobs, one with 'node exporter' and the other with 'jenkins' as shown below;

Integrate Jenkins with Prometheus to monitor the CI/CD pipeline.

Prometheus Configuration:

To configure Prometheus to scrape metrics from Node Exporter and Jenkins, you need to modify the prometheus.yml file. 
The path of prometheus.yml is; cd /etc/prometheus/ ----> ls -l ----> You can see the "prometheus.yml" file ----> sudo vi prometheus.yml ----> 
You will see the content and also there is a default job called "Prometheus" Paste the below content at the end of the file;

  - job_name: 'node_exporter'
    static_configs:
      - targets: ['<MonitoringVMip>:9100']

  - job_name: 'jenkins'
    metrics_path: '/prometheus'
    static_configs:
      - targets: ['<your-jenkins-ip>:<your-jenkins-port>']

OR PASTE THE BELOW CONTENT DIRECTLY
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: "prometheus"

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'node_exporter'
    static_configs:
      - targets: ['<MonitoringVMip>:9100']

  - job_name: 'jenkins'
    metrics_path: '/prometheus'
    static_configs:
      - targets: ['<your-jenkins-ip>:<your-jenkins-port>']


 In the above, replace <your-jenkins-ip> and <your-jenkins-port> with the appropriate IPs ----> esc ----> :wq
Also replace the public ip of monitorting VM. Dont change 9100. Even though the Monitoring server is running on 9090, dont change 9100 in the above script

Check the validity of the configuration file:
promtool check config /etc/prometheus/prometheus.yml
You should see "SUCCESS" when you run the above command, it means every configuration made so far is good.

Reload the Prometheus configuration without restarting:
curl -X POST http://localhost:9090/-/reload

Access Prometheus in browser (if already opened, just reload the page):
http://<your-prometheus-ip>:9090/targets

For Node Exporter you will see (0/1) in red colour. To resolve this, open Port number 9100 for Monitoring VM 

You should now see "Jenkins (1/1 up)" "node exporter (1/1 up)" and "prometheus (1/1 up)" in the prometheus browser.
Click on "showmore" next to "jenkins." You will see a link. Open the link in new tab, to see the metrics that are getting scraped

-------------------------------------------------------------------
5. Install Grafana (Execute in Monitoring Server VM)
-------------------------------------------------------------------
You are currently in /etc/Prometheus path.

Install Grafana on Monitoring Server;

Step 5.1: Install Dependencies:
First, ensure that all necessary dependencies are installed:
sudo apt-get update
sudo apt-get install -y apt-transport-https software-properties-common

Step 5.2: Add the GPG Key:
cd ---> You are now in ~ path
Add the GPG key for Grafana:
wget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add -

You should see OK when executed the above command.

Step 5.3: Add Grafana Repository:
Add the repository for Grafana stable releases:
echo "deb https://packages.grafana.com/oss/deb stable main" | sudo tee -a /etc/apt/sources.list.d/grafana.list

Step 5.4: Update and Install Grafana:
Update the package list and install Grafana:
sudo apt-get update
sudo apt-get -y install grafana

Step 5.5: Enable and Start Grafana Service:
To automatically start Grafana after a reboot, enable the service:
sudo systemctl enable grafana-server

Start Grafana:
sudo systemctl start grafana-server

Step 5.6: Check Grafana Status:
Verify the status of the Grafana service to ensure it's running correctly:
sudo systemctl status grafana-server

You should see "Active (running)" in green colour
Press control+c to come out

Step 5.7: Access Grafana Web Interface:
The default port for Grafana is 3000
http://<monitoring-server-ip>:3000

Default id and password is "admin"
You can Set new password or you can click on "skip now".
Click on "skip now" (If you want you can create the password)

You will see the Grafana dashboard

Adding Data Source in Grafana
The first thing that we have to do in Grafana is to add the data source
Lets add the data source;

You can either click on "connections" in the left pane or click on "data sources" in the window to add the data source
Click on "Data sources" ----> Select "Prometheus" ----> Enable "default" toogle bar ----> Connection: Paste the Prometheus url ----> Remove / at the end of url ----> Scroll down and click on "Save and test" ----> If everything is fine, you will see "green" colour tick mark.

Adding Dashboards in Grafana 
Click on "Dashboards" (left pane) ----> Here we have to add the Grafana dashboard. but as we dont know, we have to get the template of Grafana dashboard. To get the template ----> Goto browser and search for "Grafana node exporter dashboard" (URL: https://grafana.com/grafana/dashboards/1860-node-exporter-full/) ----> In the left pane, click on "Copy to clipboard" ----> Goto grafana ----> In the top right side, click on + ----> Import dashboard ----> Paste the id copied ----> Click on "Load" ----> Scroll down to see "Prometheus"  ----> Click on the dropdown ----> Select "Prometheus" ----> Clikc on "Import" ----> You can now see the dashboard ----> Click on "Save" icon in the top bar right side ----> Click on Save

Lets add another dashboard for Jenkins;
Goto browser and search for "Grafana jenkins dashboard" (URL: https://grafana.com/grafana/dashboards/9964-jenkins-performance-and-health-overview/) ----> In the left pane, click on "Copy to clipboard" ----> Goto grafana ----> In the top right side, click on + ----> Import dashboard ----> Paste the id copied ----> Click on "Load" ----> Scroll down to see "Prometheus"  ----> Click on the dropdown ----> Select "Prometheus" ----> Click on "Import" ----> You can now see the Jenkins dashboard ----> Click on "Save" icon in the top bar right side ----> Click on Save

Click on Dashboards in the left pane, you can see both the dashboards you have just added.

